Issue_000:
	* std::vmload() causes errors if loading the requested file could not happen.
	* std::vmload() causes errors which are reported later (after the first libfunc-call).
	- Running main_win, after the error occurs, hitting "NO" about debugging, crashes the VM during cleanup.
Issue_001:
	* RC-store bug:
	///////////////////
	"$_Locatable_path" : [
		"$_classes" : "In RC write: element '<rc>.ProjectEntryHolder["$_ProjectEntryHolder_entries"]["{4C2AEDE3-8E6A-457B-B047-AB26D7A4E5F4}"]["$_Locatable_path"]["$_classes"]' is of type 'ExternId' not allowed in RC files!",
		"$_Path_absolute" : FALSE,
		"$_Path_path" : "..\\Components\\FindResults\\FindResults.vcproj"
	]
	///////////////////
	
Issue_002:
	function dobj_equal (one, two) {
		local previousOverloadingEnabled1 = std::tabisoverloadingenabled(one);
		local previousOverloadingEnabled2 = std::tabisoverloadingenabled(two);
		std::tabdisableoverloading(one);
		std::tabdisableoverloading(two);
		local result = one == two;
		if (previousOverloadingEnabled1)
			std::tabenableoverloading(one);
		if (previousOverloadingEnabled2)
			std::tabenableoverloading(two);
		return result;
	}
	
	const p__Object__ObjectID_id_key = "^^%@##^)@*$*)@%)!)@";
	const p__Object__Object_id_attribute_name = "$_ObjectID";
	o = [];
	id0 = [ { p__Object__ObjectID_id_key: 34 } ];
	idproto = [
		method @operator () { return self; },
		method @operator == (this, other) {
			assert( dobj_equal(this , self) );
			local c1= (local otherid = other[p__Object__ObjectID_id_key]);
			if (c1) 
					local c2 = otherid == local myid = self[p__Object__ObjectID_id_key];
			return c1 and c2;
		},
		method @ { return "^_^ ObjectID: " + self[p__Object__ObjectID_id_key]; },
		@tostring: @self."tostring()"
	];
	std::delegate(id0, idproto);
	std::tabnewattribute(o, p__Object__Object_id_attribute_name,
		function Object_setObjectID { std::error("Setting an object ID is not allowed"); },
		std::tabmethodonme(o, method Object_getObjectID { return std::tabget(self, p__Object__Object_id_attribute_name); })
	);
	std::tabsetattribute(o, p__Object__Object_id_attribute_name, id0);
	std::print(o."$_ObjectID");
	
Issue_003:
	* Attributes do not follow delegation rules of look up (???)
//////////////////////////////////////////
	local state = [ @val: 8 ];
	local proto = [ 
		@Val {
			@set method (val) { self.val = val; }
			@get method { return self.val; }
		}
	];
	std::delegate(state, proto);
	std::print(state.Val);
